#!/usr/bin/python
from math import floor
def merge_sort(chunk):
	'''
		Uses two aux functions, merge and partition to make the sort\n
		This is a in-place merge sort, meaning that no extra space 
		is required like creating another list to store the half of one list
	'''
	partition(chunk,0, len(chunk))

def merge(list, start, middle, stop):
	left = start
	right = middle
	sorted = []
	for i in range(stop-start):

		if left == middle:
			#If the middle has been reached, there is no reason to compare
			#just add the remaining numbers
			sorted.append(list[right])
			right += 1

		elif right == stop:
			#If the stop has been reached, there is no reason to compare
			#just add the remaining numbers
			sorted.append(list[left])
			left += 1
		
		elif list[left] < list[right]:
			sorted.append(list[left])
			left += 1
			
		else:
			sorted.append(list[right])
			right += 1
	for index, val in enumerate(sorted):
		list[start + index] = val
def partition(list, start, stop):

	'''
		Splits the list in place using two indices, start and stop
	'''
	
	#If the range we want to get is less or equal than one, there is no reason to keep partitioning
	if (stop-start) == 0: return

	#Get the middle index of the current range in the list to create a new partition
	middle = start + floor((stop - start) / 2 )

	
	#Split each half generated by middle
		#Left split
	if (middle-start) > 1:
		partition(list, start, middle)

		#Right split
	if (stop - middle) > 1:
		partition(list, middle, stop)
	'''
		End of merge recursion, 
		Note: just one recursion, doesnt mean that merge has stopped calling itself
		Example:
			[9,8,7,6,5,4,3,2,1]
			[9,8,7,6]
			[9,8]
		At this point we have 9,8 so once they are split into [9] and [8], since partition wont call itself here, we 
		continue with merge
	'''
	merge(list, start, middle, stop)

if __name__ == '__main__':
	a_list = [9,8,7,6,5,4,3,2,1]
	merge_sort(a_list)
	print(a_list)